##DATA PREP

#load packages:
library(escapeLGD)
library(tidyverse)
library(lubridate)
library(devtools)
#devtools::install_github("delomast/escapeLGD")

#steelhead example, but some places might have CHN and STHD
setwd("C:\Users\david.smith\OneDrive - State of Idaho\Desktop\EASE CODE\SY2025 CHNK\Final Inputs")
#_________________________
### 1) DEFINE START AND END DATES OF THE ANALYSIS
sy <- 2025
spp <- "CHNK" # STHD or CHNK
if(spp == "CHNK"){
  start <- mdy(paste0("3/1/", sy))
  end <- mdy(paste0("8/17/", sy))
} else {
  start <- mdy(paste0("3/1/", sy))
  end <- mdy(paste0("8/17/", sy))
}



# QAQC PBT tag rates ------------------------------------------------------
tagRates <- read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_PBTTagRates.csv') %>% distinct() %>%
  setNames(c("group", "tagRate"))%>%
  mutate(tagRate = as.numeric(tagRate)) %>% #  making sure all tag rates are numbers (QAQC step 1)
  filter(tagRate > 0, !is.na(tagRate))

tagRates <- tagRates %>%
  add_row(group = "Unassigned", tagRate = 1)

summary(tagRates$tagRate)#check that rates look ok (>0 and at most 1 and no NAs) (used in QAQC step 1)

# this should be TRUE, otherwise you have duplicates (QAQC step 3)
n_distinct(tagRates$group) == nrow(tagRates) #good
#> [1] TRUE 

# standardize column names if needed
# Find groups in trap but not in tagRates
trap_groups <- unique(trap$releaseGroup)
trap_groups <- trap_groups[!is.na(trap_groups)] # Remove NA

missing_tagrates <- trap_groups[!trap_groups %in% tagRates$group]
missing_tagrates
#_________________________
### 8) CHECK THAT ALL ASSIGNED PBT SAMPLES (in trap dataset) HAVE DEFINED TAG RATES
#The "NAs introduced by coercion" warning is because some of the 
#tag rates were not numbers. These were filtered out in the 
#previous filter call. Now let's make sure that all PBT assigned samples in 
#the trap dataset have defined tag rates. (QAQC step 2)

#read-in final trap input file
trap<-read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_trap.csv')




# should have 0 rows
trap %>% count(releaseGroup) %>% left_join(tagRates, by = c("releaseGroup" = "group")) %>% #matching all release grps in trap data to those in tagRates data. If a release grp present in trap data but not tagRate data then tagRate would be NA for tht release grp(s)
  mutate(tagRate = as.numeric(tagRate)) %>%
  filter(is.na(tagRate), !is.na(releaseGroup), releaseGroup != "Unassigned") #good
# This is what matters for tag rates
trap %>% count(Rear, releaseGroup) %>% 
  filter(!is.na(releaseGroup))
#Ex when fish are missing PBT tag rates
#> # A tibble: 6 x 3
#>   releaseGroup                                                         n tagRate
#>   <chr>                                                            <int>   <dbl>
#> 1 2016-MVFH-USAL-PahsimeroiR-NoClipCWT                                40      NA
#> 2 2016-WNTH-WNTH-UNK                                                   1      NA
#> 3 2017-LYON-CGRW-CottonWoodGR/WallowaR/LyonsFerry/Touchet/WallaWa~   300      NA
#> 4 2017-MVFH-DWOR-PahsimeroiR-NoClip                                    2      NA
#> 5 2017-MVFH-USAL-YankeeForkR-AdClip                                    1      NA
#> 6 2018-LYON-CGRW-CottonWoodGR/WallowaR/LyonsFerry/Touchet/WallaWa~     1      NA

#If you have fish that are missing tag rates, need to find them and add them to the tagRates object.
#tagRates <- tagRates %>% bind_rows(
#  tibble(group = c("2017-CLWH-SFCLW-NFClearwaterR-AD","2017-DWOR-DWOR-ClearwaterR","2017-KOOS-KOOS-ClearCr"),
#         tagRate = c(.7732, .9946,.9958)))

# should have 0 rows now
#trap %>% count(releaseGroup) %>% left_join(tagRates, by = c("releaseGroup" = "group")) %>% 
#  mutate(tagRate = as.numeric(tagRate)) %>%
#  filter(is.na(tagRate), !is.na(releaseGroup), releaseGroup != "Unassigned")

write.csv(tagRates,'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_PBTtagRates.csv',row.names = F)



# Format PIT-tag data -----------------------------------------------------
pitData <- read.csv("C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_PITdata_lgr_night_reasc_daily.csv")

#This data has been filtered/processed to have one row for every ascension (each row is a unique ascension)
#1-The stock group (upper or lower for steelhead; all CHNK are Upper) the PIT tag belongs to for purposes of fallback rates
#2-The date the ascension occurred
#3-The tagID
#4-The time period, day (counting window open) or night (window closed), the ascension occurred
#5-Whether this ascension resulted in a later fall back (TRUE) or 
#not (FALSE). In other words TRUE if the fish later re-ascended, and 
#FALSE if it did not. Note that because we are running this model without 
#accounting for fallback withOUT reascension, this column could also 
#represent whether the PIT tag had previously ascended (TRUE) or not (FALSE)

#Let's make sure the period column only includes D or N and laterAscend only includes TRUE or FALSE.
#CMB 10-4-21: If it has NAs, do we remove those?....I removed 12 NAs in SY2021 dataframe...
pitData %>% count(Period)
# Period    n
# 1      D 1436
# 2      N   44

pitData %>% count(laterAscend)
# laterAscend    n
# 1       FALSE 1407
# 2        TRUE   73
head(pitData$Date)
pitData <- pitData %>% mutate(Date = ymd(Date),sWeek=week(Date))


pitData <- pitData %>% mutate(y = year(Date), w = sWeek) %>% #CMB 10-1-21: changed w= from CollectionDate to WeekNumber bc we already specified stat wk in that column.
  arrange(y, w) %>% mutate(sWeek = paste0(y, "_", w))

# fallback - creating another dataframe from pitData that has sums of reascends and total passes per statistical week
fullRe <- pitData %>% 
  group_by(stockGroup, sWeek) %>% #CMB 10-4-21: changed "week(Date)" to "WeekNum" to define sWeek differently bc of Mon-Sun.
  summarise(totalPass = length(TagID), numReascend = sum(laterAscend), .groups = "drop") %>% 
  select(sWeek, stockGroup, numReascend, totalPass)

fullRe #CMB 10-4-21: FOR STHD- MAKE SURE WEEK 27 IS SPLIT APPROPRIATELY INTO 27A (yr 2020) AND 27B (yr 2021)
#> # A tibble: 40 x 4
#>    sWeek   stockGroup numReascend totalPass
#>    <chr>   <chr>            <int>     <int>
#>  1 2019_30 lower                0         1
#>  2 2019_34 lower                0         1
#>  3 2019_36 lower                0         1
#>  4 2019_37 lower                1         2
#>  5 2019_38 lower                0         2
#>  6 2019_39 lower                0        10
#>  7 2019_40 lower                5        16
#>  8 2019_41 lower                1         7
#>  9 2019_42 lower                3        13
#> 10 2019_43 lower                1         6
#> # ... with 30 more rows

fullNi <- pitData %>% 
  group_by(sWeek) %>% 
  summarise(totalPass = length(TagID), nightPass = sum(Period == "N"), .groups = "drop") %>%
  select(sWeek, nightPass, totalPass)

#_________________________
### 11)
#Now we want to make sure there is an entry for every statistical week 
#(and stock group for the fallback input), even if it's 0. We'll do that using
#the window count data as it has all statistical weeks of the yr in it.
wc <- wc %>%
  mutate(sWeek = str_replace(sWeek, "_(\\d)$", "_0\\1"))  # Pad single digits

# Or if you don't have stringr:
wc <- wc %>%
  separate(sWeek, into = c("year", "week"), sep = "_", remove = FALSE) %>%
  mutate(sWeek = paste0(year, "_", sprintf("%02d", as.numeric(week)))) %>%
  select(sWeek, wc)
write.csv(wc, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_wc.unexpanded.csv')
#read-in final window count input file
wc<-read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_wc.unexpanded.csv')

fullReComplete <- tibble()
for(g in unique(fullRe$stockGroup)){
  fullReComplete <- fullReComplete %>% bind_rows(
    wc %>% full_join(fullRe %>% filter(stockGroup == g), by = "sWeek") %>% 
      mutate(across(c(numReascend, totalPass), replace_na, 0)) %>%
      mutate(stockGroup = replace_na(stockGroup, g))
  )
}

sum(is.na(fullReComplete$wc)) #good
## should be 0. IF NOT, you have PIT tagged fish passing when window counts aren't in wc

# only have columns you need
fullReComplete <- fullReComplete %>% select(-wc)#gets rid of wc column
write.csv(fullReComplete, "C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_fallback_fullReComplete.csv",row.names = F)

fullNiComplete <- wc %>% full_join(fullNi, by = "sWeek") %>% 
  mutate(across(c(nightPass, totalPass), replace_na, 0))

sum(is.na(fullNiComplete$wc)) #good
# should be 0, if not you have PIT tagged fish passing when window counts aren't in wc

fullNiComplete <- fullNiComplete %>% select(-wc)#gets rid of wc column 

#Now the two inputs you have are fullReComplete (fallback/reascension data) and fullNiComplete (nighttime passage data)
#Save these inputs as csv files:
write.csv(fullNiComplete, "C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_night_fullNiComplete.csv",row.names = F)



# Format GSI data ---------------------------------------------------------

#If we are NOT incorporating GSI uncertainty, we also need to 
#examine the GSI column. If we are, then we need a column linking samples to 
#rows of a separate table with GSI assignments. 
#Let's first look at the GSI assignment table:
# load it in:
gsiDraws <- read_tsv("C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK.GSIDraws.AllFish.txt")


# Read in final trap input file
trap <- read.csv("C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_trap.csv")  # Use your actual filename

# Add NAs for fish in trap data that weren't GSI genotyped
# gsiDraws structure: MasterID column + 2000 bootstrap columns (boot_1 through boot_2000)
# Each bootstrap column contains a probabilistic GSI stock assignment
# EASE requires gsiDraws to have an entry for every trapped fish (with NAs if not genotyped)

# Find MasterIDs in trap but NOT in gsiDraws
missing_ids <- trap$MasterID[!trap$MasterID %in% gsiDraws$MasterID]
length(missing_ids)  # Number of fish to add

# Create dataframe with missing MasterIDs and NAs for all 2000 bootstrap columns
na_matrix <- matrix(NA, nrow = length(missing_ids), ncol = 2000)
na_df <- as.data.frame(na_matrix)
colnames(na_df) <- paste0("boot_", 1:2000)
na_df <- cbind(MasterID = missing_ids, na_df)

# Append to gsiDraws
gsiDraws <- bind_rows(gsiDraws, na_df)

# Verify: gsiDraws and trap should now have equal row counts
nrow(trap)
nrow(gsiDraws)
all(trap$MasterID %in% gsiDraws$MasterID)  # Should be TRUE

# these should both be 0
sum(!trap$MasterID %in% gsiDraws$MasterID) #good

sum(!gsiDraws$MasterID %in% trap$MasterID)#good


#And let's look at just the first iterations values
trap %>% mutate(gsiAssignment = gsiDraws[match(MasterID, gsiDraws[[1]]),][[2]]) %>%
  count(LGDMarkAD, gsiAssignment)
# LGDMarkAD gsiAssignment     n
# 1        AD          <NA> 10312
# 2        AI        CHMBLN    47
# 3        AI          FALL   179
# 4        AI        HELLSC  1317
# 5        AI        MFSALM   355
# 6        AI        SFSALM   766
# 7        AI        TUCANO    15
# 8        AI        UPSALM   436
# 9        AI          <NA>    73

#It looks like none of the AD fish have values, which is fine - 
#we don't split them by GSI assignment. And it looks like only a 
#few AI fish which failed genotyping are missing the values - again this is 
#good, we want GSI assignments for all the AI fish, 
#regardless of PBT assignment.


#Now, the fish that HAVE a GenStock but DONT have an Age can cause errors in the model because occasionally it will come across a fish in the gsiDraws that 
#is the only fish in a stock in a specific stratum and it doesn't have an age, so the model doesn't have any data for that stock in that stratum. To fix this:
#Set the genstock (across all iterations in gsiDraws) to NA (treat it as missing) for all unmarked, untagged fish without ages. 
#You can do this using the code below. THIS STILL ALLOWS THE FISH TO BE USED TO INFORM THE HNC vs W PROPORTIONS,
#But avoids the problem of having incomplete cases

#CMB: this code finds MASTERIDs of fish that have a Genstock but no age (if we wanted to eliminate all fish without ages from the gsiDraws data,
#DON'T USE! R CODE KEPT FOR FYI!)
#gsi_draws_NA_age <- gsiDraws # create a copy of gsiDraws to modify 
#WnoAge <- trap %>% filter(is.na(Age), LGDMarkAD == "AI", is.na(physTag) | !physTag, !is.na(releaseGroup) & releaseGroup == "Unassigned") %>%
  #pull(MasterID) # List of MasterIDs of unmarked, untagged fish with no age data 

#gsi_draws_NA_age[gsi_draws_NA_age$MasterID %in% WnoAge,-1] <- NA # set fish w/o ages as missing 
# run est_comp using gsi_draws_NA_age on line 566 of Step 3 - estimate escapement R file
#^use the gsi_draws_NA_age object when creating the est_comp object on line 566 of Step 3 - estimate escapement


#CMB: UPDATED 11-10-21: the code below finds MASTERIDs of problem fish that will trigger an error while 
#running HNC_expand_unkGSI() in est_comp. 
#(aka a fish that is the only one of their stock in a single stratum and it doesnt have an age).
gsi_draws_NA_probfish <- gsiDraws # create a copy of gsiDraws to modify 



#visualize the strata
# Step 1: Create weekly summary with all needed info
library(dplyr)
library(ggplot2)

# Load data
trap <- read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_trap.csv')
wc <- read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_wc.unexpanded.csv')  # Updated filename

# Weekly summary
weekly_summary <- trap %>%
  group_by(sWeek) %>%
  summarise(
    total = n(),
    AD = sum(LGDMarkAD == "AD"),
    AI = sum(LGDMarkAD == "AI"),
    AD_genotyped = sum(LGDMarkAD == "AD" & !is.na(releaseGroup)),  # Changed from GenStock
    AI_genotyped = sum(LGDMarkAD == "AI" & !is.na(releaseGroup)),  # Changed from GenStock
    knownHN = sum(LGDMarkAD == "AI" & (physTag | (!is.na(releaseGroup) & releaseGroup != "Unassigned")))  # AI only + physTag
  ) %>%
  left_join(wc, by = "sWeek") %>%
  arrange(sWeek)

# 1. generate full list of weeks for 2025 (01–52)
all_weeks <- tibble(
  sWeek = sprintf("2025_%02d", 1:53)
)

# 2. join your existing data to it, fill missing with 0
weekly_summary <- all_weeks %>%
  left_join(weekly_summary, by = "sWeek") %>%
  mutate(across(where(is.numeric), ~ replace_na(., 0)))

weekly_summary$sWeek

target <- 325  # Target number of genotyped AI fish per stratum

strat <- weekly_summary %>%
  arrange(sWeek) %>%  # Sort weeks chronologically
  mutate(
    # Calculate running total of genotyped AI fish
    csum = cumsum(AI_genotyped),
    
    # Divide cumsum by target and round up to assign initial strata
    stratum_raw = ceiling(csum / target),
    
    # Ensure no stratum 0 (happens when early weeks have 0 fish)
    stratum_raw = ifelse(stratum_raw < 1, 1, stratum_raw),
    
    # Remove gaps in stratum numbers (e.g., 1,2,3,5,7,8,9 → 1,2,3,4,5,6,7)
    stratum = dense_rank(stratum_raw)
    
    # REMOVED the problematic merge line - pre-season weeks stay in stratum 1
  )

# Summarize final strata
strat %>%
  group_by(stratum) %>%
  summarise(
    n_weeks = n(),
    first_week = first(sWeek),
    last_week = last(sWeek),
    genotyped_AI = sum(AI_genotyped)
  )

# Compare the two
trap %>%
  summarise(
    genotyped_via_GenStock = sum(LGDMarkAD == "AI" & !is.na(GenStock)),
    genotyped_via_releaseGroup = sum(LGDMarkAD == "AI" & !is.na(releaseGroup))
  )

ggplot(strat, aes(x = sWeek, y = AI_genotyped, fill = factor(stratum))) +
  geom_col() +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(
    title = "Genotyped AI fish by week and stratum",
    x = "Statistical Week",
    y = "Genotyped AI fish",
    fill = "Stratum"
  ) +
  geom_hline(yintercept = 200, linetype = "dashed", color = "red")


# Step 1: Get AI wild fish with GSI assignments and their strata/BY
tempdata <- trap %>%
  left_join(stratComp, by = "sWeek") %>%  # Add stratum assignments
  filter(LGDMarkAD == "AI") %>%           # Ad-intact only
  filter(!is.na(GenStock)) %>%            # Has GenStock
  select(MasterID, stratum, BY, GenStock) %>%
  inner_join(gsiDraws %>% filter(!is.na(.[[2]])), by = "MasterID") %>%  # Add GSI draws
  select(MasterID, stratum, BY, everything())   # MasterID, stratum, BY, then boot columns

# Step 2: Find problem fish - those in GSI/stratum combos with NO fish with BY
# (Can't expand BY composition without at least one fish with BY per combo)
problemIterations <- tibble()

for(i in 4:ncol(tempdata)) {  # Loop through each GSI iteration column (skip MasterID, stratum, BY)
  
  # All stock-stratum combinations in this iteration
  GSIcombos <- tempdata[, c(2, i)] %>% distinct()
  
  # Stock-stratum combinations that HAVE fish with BY
  GSI_BYCombos <- tempdata[, c(2, 3, i)] %>% 
    filter(!is.na(BY)) %>%
    select(-BY) %>% 
    distinct()
  
  # Find combos that exist but have no fish with BY (problem cases)
  probCases <- GSIcombos %>%
    anti_join(GSI_BYCombos, by = c("stratum", colnames(tempdata)[i]))
  
  if(nrow(probCases) < 1) next  # No problems in this iteration, skip
  
  # Add problem fish from this iteration to master list
  problemIterations <- problemIterations %>% 
    bind_rows(
      tempdata %>% 
        semi_join(probCases, by = c("stratum", colnames(tempdata)[i])) %>%
        select(MasterID, stratum) %>% 
        mutate(iteration = i)
    )
}

# Step 3: Get unique list of problem fish and set their GSI to NA
if(nrow(problemIterations) > 0) {
  problemMasterIDs <- problemIterations %>% 
    select(MasterID, stratum) %>%
    distinct()
  
  problemfishlist <- problemMasterIDs %>% pull(MasterID)
  
  # Set all GSI draws to NA for problem fish
  gsi_draws_NA_probfish[
    gsi_draws_NA_probfish$MasterID %in% problemfishlist,
    2:ncol(gsi_draws_NA_probfish)
  ] <- NA
  
  message("Set ", length(problemfishlist), " problem fish to NA")
  print(problemMasterIDs)
} else {
  message("No problem cases found - all GSI/stratum combos have fish with BY")
}



write.csv(strat,'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_trap.strata.csv',row.names = F)

write.csv(gsiDraws,'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_gsiDraws.csv',row.names = F)
#only use when there are na fish 
write.csv(gsi_draws_NA_probfish,'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_gsiDraws_NA_probfish.csv',row.names = F)


# 11A) Define Night Passage Strata in R
# Guidelines: 
# - All strata need ≥1 ascension
# - Avoid 0% or 100% night passage (no variation for bootstrap)
# - Target ~100+ ascensions per stratum
# - Don't combine weeks with very different passage rates

# Fix sWeek formatting in fullNiComplete to match trap data (zero-padded)
fullNiComplete <- fullNiComplete %>%
  mutate(
    week_num = as.numeric(sub(".*_", "", sWeek)),  # Extract week number
    sWeek = sprintf("2025_%02d", week_num)          # Reformat with zero-padding
  ) %>%
  select(-week_num)

# Now arrange will work correctly
night_summary <- fullNiComplete %>%
  group_by(sWeek) %>%
  summarise(
    nightPass = sum(nightPass),
    totalPass = sum(totalPass),
    pct_night = round(100 * nightPass / totalPass, 1)
  ) %>%
  arrange(sWeek)  # Now sorts correctly: 2025_01, 2025_02, ..., 2025_53   

print(night_summary, n = Inf)

# Step 2: Create strata that avoid 0% or 100% night passage
target_n <- 100  # Target ascensions per stratum

stratNight <- night_summary %>%
  filter(totalPass > 0) %>%  # Remove pre-season weeks with no ascensions
  arrange(sWeek) %>%
  mutate(
    # Calculate running total of ascensions
    csum = cumsum(totalPass),
    
    # Initial stratum assignment based on target
    stratum_raw = ceiling(csum / target_n),
    stratum = dense_rank(stratum_raw)
  )

# Check each stratum for 0% or 100% night passage and fix
# Work from last to first to avoid renumbering issues
for(s in rev(unique(stratNight$stratum))) {
  strat_data <- stratNight %>% filter(stratum == s)
  total_n <- sum(strat_data$nightPass)
  total_a <- sum(strat_data$totalPass)
  pct <- ifelse(total_a > 0, total_n / total_a, 0)
  
  # If stratum has 0% or 100%, merge backward (or forward if stratum 1)
  if(pct == 0 | pct == 1) {
    if(s == 1) {
      # First stratum: merge forward into stratum 2
      stratNight <- stratNight %>%
        mutate(stratum = ifelse(stratum == 1, 2, stratum))
    } else {
      # All other strata: merge backward
      stratNight <- stratNight %>%
        mutate(stratum = ifelse(stratum == s, s - 1, stratum))
    }
  }
}

# Re-number strata to be consecutive
stratNight <- stratNight %>%
  mutate(stratum = dense_rank(stratum))

# Step 3: Check strata quality
# First, get weekly min/max per stratum
weekly_range <- stratNight %>%
  group_by(stratum) %>%
  summarise(
    min_pct = min(pct_night, na.rm = TRUE),
    max_pct = max(pct_night, na.rm = TRUE)
  )

# Then calculate stratum summaries and join
strata_check <- stratNight %>%
  group_by(stratum) %>%
  summarise(
    n_weeks = n(),
    first_week = first(sWeek),
    last_week = last(sWeek),
    total_ascensions = sum(totalPass),
    total_night = sum(nightPass),
    pct_night = round(100 * total_night / total_ascensions, 1)
  ) %>%
  left_join(weekly_range, by = "stratum")

print(strata_check)

# Step 4: Manual adjustments if needed
# If you see problems, modify specific weeks:
# stratNight <- stratNight %>%
#   mutate(stratum = case_when(
#     sWeek %in% c("2024_10", "2024_11") ~ 2,  # Force these into stratum 2
#     TRUE ~ stratum
#   ))


# Step 5: Final format for EASE - match BUILD template with all 53 weeks
# Create full week list
all_weeks_night <- tibble(sWeek = sprintf("2025_%02d", 1:53))

# Join stratification to all weeks with all data columns
stratNight_final <- all_weeks_night %>%
  left_join(stratNight %>% select(sWeek, nightPass, totalPass, pct_night, csum, stratum), 
            by = "sWeek") %>%
  fill(stratum, .direction = "down") %>%  # Fill forward for post-season weeks
  mutate(
    stratum = ifelse(is.na(stratum), 1, stratum),  # Pre-season weeks get stratum 1
    nightPass = ifelse(is.na(nightPass), 0, nightPass),  # Fill missing with 0
    totalPass = ifelse(is.na(totalPass), 0, totalPass),
    pct_night = ifelse(is.na(pct_night), 0, pct_night),
    csum = ifelse(is.na(csum), 0, csum)
  )

# Export with all data columns
stratNight_export <- stratNight_final %>%
  select(sWeek, nightPass, totalPass, pct_night, csum, stratum)
stratNight_export%>%print(n=nrow(stratNight_export))
# Save full dataset
write.csv(stratNight_export, "C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/BUILD_stratNight_SY2025CHNK_full.csv", row.names = FALSE)

# Also save just sWeek and stratum for EASE input if needed
write.csv(stratNight_final %>% select(sWeek, stratum), 
          "C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/BUILD_stratNight_SY2025CHNK.csv", row.names = FALSE)
dput(stratNight)


#fname <- paste0("BUILD_stratNight_", spp, "_", sy, ".csv") #Tom code
#write.csv(stratNight, fname, row.names = FALSE) #Tom code

##Once strata are reviewed, edit/save the "stratum" column in Excel
# and load back in
stratNight <- read.csv("C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/BUILD_stratNight_SY2025CHNK.csv")

# evaluate chosen strata
#eval <- stratNight %>% group_by(stratum) %>% 
#  summarise(across(c(nightPass, totalPass), sum), .groups = "drop")
#eval %>% mutate(noVar = nightPass == totalPass | nightPass == 0) # to manually inspect
#if(any(eval$totalPass < 1)) print("strata not acceptable, must have 1 or more totalPass in all")
# if fail, go back and reassign strata
#######This and all other strata criteria are evaluated in Excel so this above step is duplicated and can be deleted

stratNight <- stratNight %>% select(sWeek, stratum) # select needed columns. Instead of loading into R and running this code, would be quicker to delete these cols in Excel and save as a new version in final input files folder since no changes made to dataset in R


# Format Trap Strata ------------------------------------------------------
## 11B) Composition strata
#General guidelines:
  #All strata must have at least one trapped fish
  #Don't combine strata over periods when environmental variables thought to affect composition change
      #Fall/spring periods for steelhead
#50 or more genotyped AD samples and 50 or more genotyped AI samples
    #Not a magic number. Just make sure it's a reasonable sample size.


# Use strat directly for composition strata
stratComp <- strat %>%
  select(sWeek, wc, AD, AI, knownHN, AD_genotyped, AI_genotyped, stratum) %>%
  rename(knownHNC = knownHN)  # Match the expected column name

sum(is.na(stratComp$wc))

# Write to csv
write.csv(stratComp, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/BUILD_stratComp_SY2025CHNK.csv', row.names = F)# Write to csv

#fname <- paste0("BUILD_stratComp_", spp, "_", sy, ".csv") #Tom code
# write out file
#write.csv(stratComp, fname, row.names = FALSE)

#Once strata are reviewed, edit/save the "stratum" column in Excel
# and load back in
stratComp <- read.csv("C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/BUILD_stratComp_SY2025.CHNK.csv")

# evaluate chosen strata
eval <- stratComp %>% group_by(stratum) %>% 
  summarise(across(c(wc, AD, AI, knownHNC, AD_genotyped, AI_genotyped), sum), .groups = "drop")
eval %>% as.data.frame 

library(tibble)

eval_lastyear <- tribble(
  ~stratum, ~wc, ~AD, ~AI, ~knownHNC, ~AD_genotyped, ~AI_genotyped,
  1, 13254, 2260, 279, 117, 556, 254,
  2, 17814, 2934, 513, 226, 730, 504,
  3,  6128, 1236, 423, 176, 305, 414,
  4,  4823,  769, 362, 115, 177, 350,
  5,  4442,  627, 311, 108, 151, 301,
  6,  1880,  335, 217,  74,  82, 212,
  7,  2293,  282, 251,  91,  64, 239,
  8,  2171,  205, 296, 132,  47, 289
)

# Create two labeled datasets
eval_2025 <- eval %>%
  mutate(year = 2025) %>%
  select(year, stratum, AI_genotyped,wc)

eval_2024 <- eval_lastyear %>%   # rename your old object if needed
  mutate(year = 2024) %>%
  select(year, stratum, AI_genotyped,wc)

eval_comp <- bind_rows(eval_2025, eval_2024)

# Create scaling factor so wc fits roughly the same visual range as AI_genotyped
scaleFactor <- max(eval_comp$wc) / max(eval_comp$AI_genotyped)

ggplot(eval_comp, aes(x = factor(stratum))) +
  # Bars for AI_genotyped
  geom_col(aes(y = AI_genotyped, fill = factor(year)),
           position = position_dodge(width = 0.8), width = 0.7) +
  
  # Line for window counts (scaled)
  geom_line(aes(y = wc / scaleFactor, group = factor(year), color = factor(year)),
            size = 1.2, linetype = "solid") +
  geom_point(aes(y = wc / scaleFactor, color = factor(year)), size = 2) +
  
  # Formatting
  theme_minimal(base_size = 13) +
  scale_y_continuous(
    name = "AI Genotyped Fish",
    sec.axis = sec_axis(~ . * scaleFactor, name = "Window Count (wc)")  # secondary axis
  ) +
  scale_fill_manual(values = c("tomato", "steelblue")) +
  scale_color_manual(values = c("tomato3", "steelblue4")) +
  labs(
    title = "AI Genotyped Fish and Window Counts by Stratum",
    x = "Stratum",
    fill = "Year (AI Genotyped)",
    color = "Year (Window Count)"
  ) +
  geom_hline(yintercept = 325, linetype = "dashed", color = "red") +
  annotate("text", x = Inf, y = 325, label = "Target = 325", 
           hjust = 1.1, vjust = -0.4, color = "red", size = 3) +
  theme(
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 0),
    plot.title = element_text(face = "bold"),
    legend.position = "bottom"
  )

# to manually inspect
# stratum    wc   AD  AI knownHNC AD_genotyped AI_genotyped
# 1       1 13547 2559 326      136          730          300
# 2       2  9098 1940 357      143          467          346
# 3       3  9740 2123 455      166          519          449
# 4       4  7116 1711 505      150          424          488
# 5       5  3642  621 288       71          154          279
# 6       6  3271  497 368       60          123          363
# 7       7  2196  309 263       54           75          260
# 8       8  3488  402 416       90           94          412
# 9       9  1616  150 210       73           36          205
#if(any((eval$AD + eval$AI) < 1)) print("strata not acceptable, must have 1 or more trapped fish in all")
# if fail, go back and reassign strata
#This and all other strata criteria are evaluated in Excel so this above step is duplicated and can be deleted

stratComp <- stratComp %>% select(sWeek, stratum) # select columns you need. Instead of loading into R and running this code, would be quicker to delete these cols in Excel and save


#Based on the 2024 strata you've shown and the example code, here's how to build your fallback strata:
# Format Fallback-Reascension Strata for SY2025 -------------------------
# Load composition strata first
stratComp <- strat %>%
  select(sWeek, stratum)

# Simple: fallback = composition
stratFallback <- fullReComplete %>%
  left_join(stratComp %>% rename(compStratum = stratum), by = "sWeek") %>%
  mutate(stratum = ifelse(is.na(compStratum), min(stratComp$stratum, na.rm = TRUE), compStratum)) %>%
  select(stockGroup, sWeek, stratum)

library(escapeLGD)
checkStrata(stratAssign_comp = stratComp, stratAssign_fallback = stratFallback)

# Evaluate
eval <- stratFallback %>%
  left_join(fullReComplete, by = c("stockGroup", "sWeek")) %>%
  filter(totalPass > 0) %>%
  group_by(stockGroup, stratum) %>%
  summarise(
    weeks = paste(range(sWeek), collapse = " to "),
    numReascend = sum(numReascend), 
    totalPass = sum(totalPass), 
    .groups = "drop"
  )

eval %>% mutate(noVar = numReascend == 0 | numReascend == totalPass)

# Verify
checkStrata(stratAssign_comp = stratComp, stratAssign_fallback = stratFallback)

# Must have at least 1 totalPass
if(any(eval$totalPass < 1)) print("ERROR: strata not acceptable, must have 1+ totalPass")

# Select needed columns
stratFallback <- stratFallback %>% select(stockGroup, sWeek, stratum)

# Check compatibility with composition strata
checkStrata(stratAssign_comp = stratComp, stratAssign_fallback = stratFallback)


# A tibble: 9 × 6
# stockGroup stratum weeks              numReascend totalPass noVar
# <chr>        <int> <chr>                    <int>     <int> <lgl>
#   1 upper            1 2025_12 to 2025_20          28       321 FALSE
# 2 upper            2 2025_21 to 2025_21           5       194 FALSE
# 3 upper            3 2025_22 to 2025_22          15       277 FALSE
# 4 upper            4 2025_23 to 2025_23           6       158 FALSE
# 5 upper            5 2025_24 to 2025_24           5       151 FALSE
# 6 upper            6 2025_25 to 2025_25           2       117 FALSE
# 7 upper            7 2025_26 to 2025_26           2        87 FALSE
# 8 upper            8 2025_27 to 2025_29           8       119 FALSE
# 9 upper            9 2025_30 to 2025_33           2        56 FALSE
if(any(eval$totalPass < 1)) print("strata not acceptable, must have 1 or more totalPass in all")

stratFallback
# A tibble: 53 × 3
# stockGroup sWeek   stratum
# <chr>      <chr>     <int>
#   1 upper      2025_01       1
# 2 upper      2025_02       1
# 3 upper      2025_03       1
# 4 upper      2025_04       1
# 5 upper      2025_05       1
# 6 upper      2025_06       1
# 7 upper      2025_07       1
# 8 upper      2025_08       1
# 9 upper      2025_09       1
# 10 upper      2025_10       1
# # ℹ 43 more rows
# # ℹ Use `print(n = ...)` to see more rows


dput(stratFallback)


#get the strata checked out: 
# 1. COMPOSITION STRATA SUMMARY (already has all 53 weeks)
comp_summary <- strat %>%
  group_by(stratum) %>%
  summarise(
    weeks = paste(range(sWeek), collapse = " to "),
    n_weeks = n(),
    total_fish = sum(total, na.rm = TRUE),
    AD_count = sum(AD, na.rm = TRUE),
    AI_count = sum(AI, na.rm = TRUE),
    AD_genotyped = sum(AD_genotyped, na.rm = TRUE),
    AI_genotyped = sum(AI_genotyped, na.rm = TRUE),
    knownHN = sum(knownHN, na.rm = TRUE),
    total_wc = sum(wc, na.rm = TRUE),
    .groups = "drop"
  )

# 2. FALLBACK STRATA SUMMARY (include all weeks)
fallback_summary <- stratFallback %>%
  left_join(fullReComplete, by = c("stockGroup", "sWeek")) %>%
  group_by(stockGroup, stratum) %>%
  summarise(
    weeks = paste(range(sWeek), collapse = " to "),
    n_weeks = n(),
    numReascend = sum(numReascend, na.rm = TRUE),
    totalPass = sum(totalPass, na.rm = TRUE),
    fallback_rate = round(numReascend / totalPass, 4),
    .groups = "drop"
  )

# 3. NIGHTTIME PASSAGE STRATA SUMMARY (include all weeks)
night_summary <- stratNight %>%
  left_join(fullNiComplete, by = "sWeek") %>%
  group_by(stratum) %>%
  summarise(
    weeks = paste(range(sWeek), collapse = " to "),
    n_weeks = n(),
    nightPass = sum(nightPass, na.rm = TRUE),
    totalPass = sum(totalPass, na.rm = TRUE),
    night_rate = round(nightPass / totalPass, 4),
    .groups = "drop"
  )
strat<-read.csv("SY2025CHNK_trap.strata.csv")
# Weekly detail for composition
comp_weekly <- strat %>%
  select(sWeek, stratum, total, AD, AI, AD_genotyped, AI_genotyped, knownHN, wc)

# Weekly detail for fallback
fallback_weekly <- stratFallback %>%
  left_join(fullReComplete, by = c("stockGroup", "sWeek")) %>%
  mutate(fallback_rate = round(numReascend / totalPass, 4)) %>%
  select(stockGroup, sWeek, stratum, numReascend, totalPass, fallback_rate)

# Weekly detail for night
night_weekly <- stratNight %>%
  left_join(fullNiComplete, by = "sWeek") %>%
  mutate(night_rate = round(nightPass / totalPass, 4)) %>%
  select(sWeek, stratum, nightPass, totalPass, night_rate)

# Export summaries
write.csv(comp_summary, "SY2025_CHNK_trap_strata_SUMMARY.csv", row.names = FALSE)
write.csv(fallback_summary, "SY2025_CHNK_fallback_strata_SUMMARY.csv", row.names = FALSE)
write.csv(night_summary, "SY2025_CHNK_night_strata_SUMMARY.csv", row.names = FALSE)

# Export weekly detail
write.csv(comp_weekly, "SY2025_CHNK_trap_strata_WEEKLY.csv", row.names = FALSE)
write.csv(fallback_weekly, "SY2025_CHNK_fallback_strata_WEEKLY.csv", row.names = FALSE)
write.csv(night_weekly, "SY2025_CHNK_night_strata_WEEKLY.csv", row.names = FALSE)

# View them
comp_summary
fallback_summary
night_summary

#once approved write in strata
write.csv(stratFallback, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_stratFallback.csv', row.names = FALSE)
write.csv(stratComp,'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_Comp.strata.csv',row.names = F)
write.csv(stratNight, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_stratNight.csv', row.names = FALSE)


library(tidyverse)
#get SCOBI files--------------------

#get rid of the question marks
trap <- trap %>% filter(is.na(swAge) | swAge != "?")


trap_scobi <- trap %>%
  dplyr::mutate(
    CalenderYear = y,
    BioScaleFinalAge = BioScaleFinalAge.1,
    GenPBT_ByHatGenPBT_RGroup = releaseGroup  # or create concatenation if needed
  ) %>%
  dplyr::select(
    MasterID,
    SpawnYear,
    CollectionDate,
    sWeek,
    CalenderYear,
    WeekNumber,
    LGDSpecies,
    LGDFLmm,
    SRR,
    LGDMarkAD,
    physTag,
    GenMa,
    GenPa,
    PBTBYHat,
    PBTRGroup,
    Rear,
    GenSex,
    GenStock,
    MPG,
    BioScaleFinalAge,
    fwAge,
    swAge,
    Age,
    totalAge,
    BY,
    GenPBT_ByHatGenPBT_RGroup,
    lenCat,
    LGDTagsAll,
    PtagisFlags
  )

str(trap_scobi)
write.csv(trap_scobi, "SY2025CHNK_trap_forSCOBI.csv", row.names = FALSE)

wc_scobi <- comp_weekly %>%
  mutate(
    Strata = as.numeric(str_extract(sWeek, "(?<=_)[0-9]+")),
    Count = round(wc / (5/6),digits=0),
    Collapse = stratum
  ) %>%
  select(Strata, Count, Collapse)

write.csv(wc_scobi, "SY2025CHNK_wc_forSCOBI.csv", row.names = FALSE)


dput(tagRates)

tagRates_scobi <- tagRates %>%
  dplyr::rename(
    PBT_RELEASE_GROUP = group,
    PBT_RELEASE_GROUP_TAGRATE = tagRate
  )
tagRates_scobi

write.csv(tagRates_scobi,
          "SY2025CHNK_tagRates_forSCOBI.csv",
          row.names = FALSE)

str(read.csv("SY2025CHNK_trap_forSCOBI.csv"))
str(read.csv("SY2025CHNK_wc_forSCOBI.csv"))
str(read.csv("SY2025CHNK_tagRates_forSCOBI.csv"))

trap2 <- read.csv("SY2025CHNK_trap_forSCOBI.csv")
tags2 <- read.csv("SY2025CHNK_tagRates_forSCOBI.csv")

setdiff(unique(trap2$GenPBT_RGroup), tags2$PBT_RELEASE_GROUP)


# Save final inputs -------------------------------------------------------
# FINAL: SAVE ALL INPUTS AS A ".RDA" FILE
#Now you have all the inputs for estimating escapement. 
#I recommend saving all of the inputs as and ".rda" file to make the 
#analysis easily reproducible/editable in the future.
# Read verified finals

#get rid of rownames, somewhere I saved a row name need to fix this in next version
fullReComplete <- fullReComplete %>% select(-X)
fullNiComplete <- fullNiComplete %>% select(-X)
wc <- wc %>% select(-X)

# Re-save all CSVs without row names
write.csv(trap, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_trap.csv', row.names = FALSE)
write.csv(wc, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_wc.unexpanded.csv', row.names = FALSE)
write.csv(tagRates, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_PBTtagRates.csv', row.names = FALSE)
write.csv(fullReComplete, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_fallback_fullReComplete.csv', row.names = FALSE)
write.csv(fullNiComplete, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_night_fullNiComplete.csv', row.names = FALSE)
write.csv(gsi_draws_NA_probfish, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_gsiDraws_NA_probfish.csv', row.names = FALSE)
write.csv(stratComp, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_Comp.strata.csv', row.names = FALSE)
write.csv(stratFallback, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_stratFallback.csv', row.names = FALSE)
write.csv(stratNight, 'C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_stratNight.csv', row.names = FALSE)

# Now read them all back in clean
trap <- read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_trap.csv')
wc <- read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_wc.unexpanded.csv')
tagRates <- read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_PBTtagRates.csv')
fullNiComplete <- read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_night_fullNiComplete.csv')
fullReComplete <- read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_fallback_fullReComplete.csv')
gsi_draws_NA_probfish <- read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_gsiDraws_NA_probfish.csv')
stratComp <- read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_Comp.strata.csv')
stratFallback <- read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_stratFallback.csv')
stratNight <- read.csv('C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/SY2025CHNK_stratNight.csv')



save(trap, wc, tagRates, fullNiComplete, fullReComplete, gsi_draws_NA_probfish,
     stratComp, stratFallback, stratNight, 
     file = paste0("escapeLGD_FINAL INPUTS_", spp, "_", sy, ".rda"))











