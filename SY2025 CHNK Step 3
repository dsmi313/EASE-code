# ESTIMATE ESCAPEMENT
library(escapeLGD)
library(tidyverse)
library(beepr)

# Set parameters
numBoots <- 1000
set.seed(7)
alpha_ci <- 0.05  # 95% CI (use 0.1 for 90% CI)
sy <- 2025
spp <- "CHNK"


# Load inputs
load("C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Final Inputs/escapeLGD_FINAL INPUTS_CHNK_2025.rda")

#________________________________________________________________________
### 1) NIGHTTIME PASSAGE AND FALLBACK RATE (DO ONCE, APPLIES TO ALL RUNS)
# Here we are estimating nighttime passage rates and fallback rates. 
# We are assuming that the rate of fallback withOUT reascension is 0.

# fullReComplete: tibble with four columns
# sWeek: the statistical week
# stockGroup: the group for which fallback and reascension is being estimated
# numReascend: the number of PIT ascensions that later reascended (d_f)
# totalPass: the total number of PIT ascensions (d_as)

# Important clarifying points:
# totalPass is the total number of PIT ASCENSIONS, NOT unique fish
# numReascend is the number of ascensions that later reascended, regardless of when

# fullNiComplete: tibble with three columns
# sWeek: the statistical week
# nightPass: the number of PIT ascensions that were at night (d_n)
# totalPass: the total number of PIT ascensions (d_a)

# Verify that totalPass sums match
sum(fullNiComplete$totalPass)  # Should equal fullReComplete
sum(fullReComplete$totalPass)

nf <- nightFall(full_reascend = fullReComplete, full_night = fullNiComplete,
                stratAssign_fallback = stratFallback, stratAssign_night = stratNight,
                full_spillway = NULL, boots = numBoots)

# "full_spillway = NULL" assumes no fallback without reascension 
# (i.e., EVERY fish that falls back reascends)

# What's in nf:
# nf$fallback_rates[[1]] = point estimates (p_fa) of fallback rate for each stockGroup x stratum
# nf$fallback_rates[[2]] = bootstrap estimates (columns = strata, rows = boot iterations)
# nf$nightPassage_rates[[1]] = point estimates (p_night) of nighttime passage rate for each stratum
# nf$nightPassage_rates[[2]] = bootstrap estimates (columns = strata, rows = boot iterations)

#________________________________________________________________________
### 2) TOTAL NUMBER OF ASCENSIONS (DO ONCE, APPLIES TO ALL RUNS)

# We need to:
# 1. Adjust for the proportion of time counting is performed during the day
# 2. Add in nighttime passage using the rates estimated in step 1

# wc: tibble with window counts by week (NOT expanded for counting time)
# sWeek: the statistical week
# wc: the number of fish counted that week

# Check that composition strata are compatible with fallback strata
# (Only one fallback stratum per comp stratum)
checkStrata(stratAssign_comp = stratComp, stratAssign_fallback = stratFallback)

exp_wc <- expand_wc_binom_night(nightPassage_rates = nf$nightPassage_rates, wc = wc,
                                wc_prop = 5/6, stratAssign_comp = stratComp,
                                stratAssign_night = stratNight, alpha_ci = alpha_ci, boots = numBoots)

# Note: Use wc_prop = 1 for old SCOBI method; use 5/6 for EASE

# What's in exp_wc:
# exp_wc[[1]] = point estimates for total ascensions in each composition stratum
# exp_wc[[2]] = bootstrap estimates (columns = strata, rows = boot iterations)
# exp_wc[[3]] = overall nighttime passage rate with 95% CI for entire run

overallNightPass <- exp_wc[[3]]

#________________________________________________________________________
### 3) RANDOMIZE GSI DRAWS (DO ONCE BEFORE FIRST RUN)

# Randomize the order of GSI draws to incorporate GSI uncertainty
# ONLY RUN THIS ONCE before the first run!
gsi_draws_NA_probfish <- gsi_draws_NA_probfish[,c(1, sample(2:ncol(gsi_draws_NA_probfish), 
                                                            size = ncol(gsi_draws_NA_probfish) - 1, replace = FALSE))]

# gsi_draws_NA_probfish structure:
# First column = sample identifier (MasterID)
# Other columns = GSI assignments (each column is one draw from posterior)
# Fish not assessed for GSI or problem fish = "NA"

#________________________________________________________________________
#________________________________________________________________________
# RUN 1 ----------------------------------------------------------------
# W = Stock, Size; H = Size; HNC = Size
# This run produces Figure 2 (escapement by origin and size)

setwd("C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Output/Run1")
load("C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Output/Run1/SY2025CHNK_ANALYSIS_RUN_1_numBoots1000.rda")
RUN <- "RUN_1"
w <- c("GenStock", "lenCat")  # Wild: estimate by stock, then size within stock
h <- c("lenCat")              # Ad-clipped hatchery: estimate by size
hnc <- c("lenCat")            # Ad-intact hatchery: estimate by size

# trap data needs these columns:
# MasterID: sample ID matching gsi_draws_NA_probfish
# releaseGroup: PBT assignments ("Unassigned" or "NA")
# sWeek: statistical week
# physTag: TRUE/FALSE for physical tag presence
# LGDMarkAD: "AD" or "AI" (no other values allowed)
# Plus any variables you're estimating (GenStock, lenCat, Age, swAge, BY, GenSex)

# tagRates: tibble with release group names and tag rates (must be > 0 and <= 1)

# Estimate composition (~40 min with 1000 bootstraps)
est_comp1 <- HNC_expand_unkGSI(trap = trap, stratAssign_comp = stratComp, 
                               boots = numBoots,
                               pbt_var = "releaseGroup", timestep_var = "sWeek", 
                               physTag_var = "physTag", adclip_var = "LGDMarkAD", 
                               sampID = "MasterID", tagRates = tagRates,
                               H_vars = h, HNC_vars = hnc, W_vars = w, 
                               wc_binom = exp_wc, GSI_draws = gsi_draws_NA_probfish, 
                               n_point = ceiling(.1 * numBoots), GSI_var = "GenStock",
                               method = "MLE")

# n_point = number of GSI draws to use for point estimate (recommend 100 for 1000 boots)
# method options: "MLE" or "Acc" (accounting method)
# Alternative functions: HNC_expand (treats GSI as fixed), ascension_composition (old SCOBI method)

# You may get warnings about non-convergence of MLE estimator
# This is normal if < 1% of (numBoots * number of strata) iterations
# If many warnings, check data inputs or try accounting method

beep(sound = 8)
save(est_comp1, file = "SY2025CHNK_est_comp_RUN1.RData")
write.csv(est_comp1[[1]], 'SY2025CHNK_est_comp1_RUN1.csv', row.names = F)
write.csv(est_comp1[[2]], 'SY2025CHNK_est_comp2_boots_RUN1.csv', row.names = F)

# What's in est_comp1:
# est_comp1[[1]] = point estimates for ascensions by stratum and category (rear, var1, var2)
#                  Rows with NA for var2 = totals for var1 category
# est_comp1[[2]] = bootstrap estimates for ascensions

# Create templates for fallback rate assignment
templates1 <- apply_fallback_rates(breakdown = est_comp1, fallback_rates = nf$fallback_rates,
                                   split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                   H_groups = NULL, HNC_groups = NULL, W_groups = NULL,
                                   stratAssign_fallback = stratFallback, stratAssign_comp = stratComp, 
                                   alpha_ci = alpha_ci, output_type = "summary")

# split_*_fallback tells which variable ("var1", "var2", or "both") determines fallback rate
# Passing NULL to H_groups, HNC_groups, W_groups returns templates to fill in

# For CHNK: all stock groups are "upper"
templates1$HNC <- templates1$HNC %>% mutate(stockGroup = "upper")
templates1$H <- templates1$H %>% mutate(stockGroup = "upper")
templates1$W <- templates1$W %>% mutate(stockGroup = "upper")

# Verify stockGroup assignments are valid
for(i in 1:3) {
  templates1[[i]] %>% count(stockGroup) %>% print
}

# Apply fallback rates to get escapement estimates
est_escp1 <- apply_fallback_rates(breakdown = est_comp1, fallback_rates = nf$fallback_rates,
                                  split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                  H_groups = templates1$H, HNC_groups = templates1$HNC, W_groups = templates1$W,
                                  stratAssign_fallback = stratFallback, stratAssign_comp = stratComp, 
                                  alpha_ci = alpha_ci, output_type = "summary")

# What's in est_escp1:
# est_escp1$output = escapement estimates and CIs for all groups (rear, var1, var2)
# est_escp1$rearType = total escapement within the three rear types

est_escp_rearType1 <- est_escp1$rearType

# Get full output with bootstrap and stratum breakdown
full_est_escp1 <- apply_fallback_rates(breakdown = est_comp1, fallback_rates = nf$fallback_rates,
                                       split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                       H_groups = templates1$H, HNC_groups = templates1$HNC, W_groups = templates1$W,
                                       stratAssign_fallback = stratFallback, stratAssign_comp = stratComp,
                                       alpha_ci = alpha_ci, output_type = "full")

# What's in full_est_escp1:
# $output = same as est_escp1$output
# $full_breakdown_H/HNC/W = point estimates by strata
# $boot_breakdown_H/HNC/W = estimates by strata for each bootstrap iteration

# Calculate marginal totals for var2 (size classes across all stocks)
marginal_var2_1 <- full_est_escp1$output %>%
  filter(!is.na(var2)) %>% group_by(rear, var2) %>%
  summarise(pointEst = sum(pointEst), .groups = "drop_last") %>%
  left_join(
    bind_rows(full_est_escp1$boot_breakdown_H, full_est_escp1$boot_breakdown_HNC, full_est_escp1$boot_breakdown_W) %>%
      filter(!is.na(var2)) %>% group_by(rear, var2, boot) %>% summarise(total = sum(total), .groups = "drop_last") %>%
      summarise(lci = quantile(total, alpha_ci / 2), uci = quantile(total, 1 - (alpha_ci / 2)), .groups = "drop_last"),
    by = c("rear", "var2"))

# Calculate MPG estimates (RUN 1 ONLY)
# For CHNK: combine CHMBLN into MFSALM for MPG grouping
full_est_escp1$output2 <- full_est_escp1$output
full_est_escp1$boot_breakdown_H2 <- full_est_escp1$boot_breakdown_H
full_est_escp1$boot_breakdown_HNC2 <- full_est_escp1$boot_breakdown_HNC
full_est_escp1$boot_breakdown_W2 <- full_est_escp1$boot_breakdown_W

full_est_escp1$output2[full_est_escp1$output2 == 'CHMBLN'] <- 'MFSALM'
full_est_escp1$boot_breakdown_H2[full_est_escp1$boot_breakdown_H2 == 'CHMBLN'] <- 'MFSALM'
full_est_escp1$boot_breakdown_HNC2[full_est_escp1$boot_breakdown_HNC2 == 'CHMBLN'] <- 'MFSALM'
full_est_escp1$boot_breakdown_W2[full_est_escp1$boot_breakdown_W2 == 'CHMBLN'] <- 'MFSALM'

marginal_MPG <- full_est_escp1$output2 %>%
  filter(is.na(var2)) %>% group_by(rear, var1) %>%
  summarise(pointEst = sum(pointEst), .groups = "drop_last") %>%
  left_join(
    bind_rows(full_est_escp1$boot_breakdown_H2, full_est_escp1$boot_breakdown_HNC2, full_est_escp1$boot_breakdown_W2) %>%
      filter(is.na(var2)) %>% group_by(rear, var1, boot) %>% summarise(total = sum(total), .groups = "drop_last") %>%
      summarise(lci = quantile(total, alpha_ci / 2), uci = quantile(total, 1 - (alpha_ci / 2)), .groups = "drop_last"),
    by = c("rear", "var1")) %>% 
  filter(rear == "W")



# Calculate overall fallback rates (RUN 1 ONLY)
# Point estimate: p_fa = 1 - (escapement / total ascensions)
fallPoint <- est_comp1[[1]] %>% filter(is.na(var2)) %>% group_by(rear, var1) %>%
  summarise(total = sum(total)) %>% 
  full_join(est_escp1$output %>% filter(is.na(var2))) %>% 
  left_join(bind_rows(templates1$H %>% mutate(rear = "H"), templates1$HNC %>% mutate(rear = "HNC"), 
                      templates1$W %>% mutate(rear = "W"))) %>% 
  group_by(stockGroup) %>%
  summarise(total = sum(total), pointEst = sum(pointEst)) %>%
  mutate(p_fa = 1 - (pointEst / total))

# Calculate CIs for fallback rates
full_fallback <- apply_fallback_rates(breakdown = est_comp1, fallback_rates = nf$fallback_rates,
                                      split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                      H_groups = templates1$H, HNC_groups = templates1$HNC, W_groups = templates1$W,
                                      stratAssign_fallback = stratFallback, stratAssign_comp = stratComp, 
                                      alpha_ci = alpha_ci, output_type = "full")

fallCI <- bind_rows(full_fallback$boot_breakdown_H, full_fallback$boot_breakdown_HNC, full_fallback$boot_breakdown_W) %>%
  filter(is.na(var2)) %>% group_by(boot, rear, var1) %>%
  summarise(escapement = sum(total)) %>% 
  full_join(est_comp1[[2]] %>% filter(is.na(var2)) %>% group_by(boot, rear, var1) %>%
              summarise(total = sum(total))) %>% 
  left_join(bind_rows(templates1$H %>% mutate(rear = "H"), templates1$HNC %>% mutate(rear = "HNC"), 
                      templates1$W %>% mutate(rear = "W"))) %>% 
  group_by(boot, stockGroup) %>%
  summarise(total = sum(total), escapement = sum(escapement)) %>%
  mutate(p_fa = 1 - (escapement / total)) %>% 
  group_by(stockGroup) %>%
  summarise(lci = quantile(p_fa, 0.025), uci = quantile(p_fa, 0.975))

OverallFallbackRates <- full_join(fallPoint, fallCI)

# DABOM output (RUN 1 ONLY)
# Nez Perce Tribe uses this for DABOM model
# Uses 90% CI (alpha_ci = 0.1) instead of 95%
est_escp_DABOM1 <- apply_fallback_rates(breakdown = est_comp1, fallback_rates = nf$fallback_rates,
                                        split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                        H_groups = templates1$H, HNC_groups = templates1$HNC, W_groups = templates1$W,
                                        stratAssign_fallback = stratFallback, stratAssign_comp = stratComp, 
                                        alpha_ci = 0.1, output_type = "W_boot")

# What's in est_escp_DABOM1:
# $output = summary table with 90% CIs
# $W_boot = wild fish estimates by stratum and bootstrap iteration (for DABOM input)

# RUN 1 - Round estimates to whole fish
full_est_escp1$output <- full_est_escp1$output %>% mutate(across(where(is.numeric), \(x) round(x, 0)))
marginal_var2_1 <- marginal_var2_1 %>% mutate(across(where(is.numeric), \(x) round(x, 0)))
est_escp_rearType1 <- est_escp_rearType1 %>% mutate(across(where(is.numeric), \(x) round(x, 0)))
marginal_MPG <- marginal_MPG %>% mutate(across(where(is.numeric), \(x) round(x, 0)))
# Extract H and HNC size estimates
H_HNC_size_1 <- full_est_escp1$output %>%
  filter(rear %in% c("H", "HNC"), is.na(var2)) %>%
  rename(lenCat = var1) %>%
  select(rear, lenCat, pointEst, lci, uci) %>%
  mutate(across(where(is.numeric), \(x) round(x, 0)))

# Save it
write.csv(H_HNC_size_1, "SY2025CHNK_H_HNC_size_SUMMARY_OUTPUT_RUN_1.csv", row.names = F)
# Save RUN 1 outputs
write.csv(full_est_escp1$output, "SY2025CHNK_full_est_escp_SUMMARY_OUTPUT_RUN_1.csv", row.names = F)
write.csv(marginal_var2_1, "SY2025CHNK_marginal_var2_SUMMARY_OUTPUT_RUN_1.csv", row.names = F)
write.csv(est_escp_rearType1, "SY2025CHNK_rearType_SUMMARY_OUTPUT_RUN_1.csv", row.names = F)
write.csv(marginal_MPG, "SY2025CHNK_marginal_MPG_SUMMARY_OUTPUT.csv", row.names = F)
write.csv(OverallFallbackRates, "SY2025CHNK_OverallFallbackRates.csv", row.names = F)
write.csv(est_escp_DABOM1$output, 'SY2025CHNK_est_escp_DABOM_output_RUN_1.csv', row.names = F)
write.csv(est_escp_DABOM1$W_boot, 'SY2025CHNK_est_escp_DABOM_W_boot_RUN_1.csv', row.names = F)

# Save RUN 1 workspace objects
save(est_comp1, templates1, est_escp1, full_est_escp1, est_escp_rearType1,
     marginal_var2_1, marginal_MPG, OverallFallbackRates, est_escp_DABOM1,
     file = "SY2025CHNK_ANALYSIS_RUN_1_numBoots1000.rda")

# RUN 2 ----------------------------------------------------------------
# W = Stock, Age; H = Release Group; HNC = Release Group
# This run produces Table 1 (wild fish by stock and age class)

setwd("C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Output/Run2")

RUN <- "RUN_2"
w <- c("GenStock", "Age")  # Wild: estimate by stock, then total age within stock
h <- c("releaseGroup")     # Ad-clipped hatchery: estimate by release group
hnc <- c("releaseGroup")   # Ad-intact hatchery: estimate by release group

# Estimate composition (~25 min with 1000 bootstraps)
est_comp2 <- HNC_expand_unkGSI(trap = trap, stratAssign_comp = stratComp, 
                               boots = numBoots,
                               pbt_var = "releaseGroup", timestep_var = "sWeek", 
                               physTag_var = "physTag", adclip_var = "LGDMarkAD", 
                               sampID = "MasterID", tagRates = tagRates,
                               H_vars = h, HNC_vars = hnc, W_vars = w, 
                               wc_binom = exp_wc, GSI_draws = gsi_draws_NA_probfish, 
                               n_point = ceiling(.1 * numBoots), GSI_var = "GenStock",
                               method = "MLE")

beep(sound = 8)
save(est_comp2, file = "SY2025CHNK_est_comp_RUN2.RData")
write.csv(est_comp2[[1]], 'SY2025CHNK_est_comp1_RUN2.csv', row.names = F)
write.csv(est_comp2[[2]], 'SY2025CHNK_est_comp2_boots_RUN2.csv', row.names = F)

templates2 <- apply_fallback_rates(breakdown = est_comp2, fallback_rates = nf$fallback_rates,
                                   split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                   H_groups = NULL, HNC_groups = NULL, W_groups = NULL,
                                   stratAssign_fallback = stratFallback, stratAssign_comp = stratComp, 
                                   alpha_ci = alpha_ci, output_type = "summary")

templates2$HNC <- templates2$HNC %>% mutate(stockGroup = "upper")
templates2$H <- templates2$H %>% mutate(stockGroup = "upper")
templates2$W <- templates2$W %>% mutate(stockGroup = "upper")

est_escp2 <- apply_fallback_rates(breakdown = est_comp2, fallback_rates = nf$fallback_rates,
                                  split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                  H_groups = templates2$H, HNC_groups = templates2$HNC, W_groups = templates2$W,
                                  stratAssign_fallback = stratFallback, stratAssign_comp = stratComp, 
                                  alpha_ci = alpha_ci, output_type = "summary")

est_escp_rearType2 <- est_escp2$rearType

full_est_escp2 <- apply_fallback_rates(breakdown = est_comp2, fallback_rates = nf$fallback_rates,
                                       split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                       H_groups = templates2$H, HNC_groups = templates2$HNC, W_groups = templates2$W,
                                       stratAssign_fallback = stratFallback, stratAssign_comp = stratComp,
                                       alpha_ci = alpha_ci, output_type = "full")

marginal_var2_2 <- full_est_escp2$output %>%
  filter(!is.na(var2)) %>% group_by(rear, var2) %>%
  summarise(pointEst = sum(pointEst), .groups = "drop_last") %>%
  left_join(
    bind_rows(full_est_escp2$boot_breakdown_H, full_est_escp2$boot_breakdown_HNC, full_est_escp2$boot_breakdown_W) %>%
      filter(!is.na(var2)) %>% group_by(rear, var2, boot) %>% summarise(total = sum(total), .groups = "drop_last") %>%
      summarise(lci = quantile(total, alpha_ci / 2), uci = quantile(total, 1 - (alpha_ci / 2)), .groups = "drop_last"),
    by = c("rear", "var2"))

# RUN 2 - Round estimates to whole fish
full_est_escp2$output <- full_est_escp2$output %>% mutate(across(where(is.numeric), \(x) round(x, 0)))
marginal_var2_2 <- marginal_var2_2 %>% mutate(across(where(is.numeric), \(x) round(x, 0)))
est_escp_rearType2 <- est_escp_rearType2 %>% mutate(across(where(is.numeric), \(x) round(x, 0)))

write.csv(full_est_escp2$output, "SY2025CHNK_full_est_escp_SUMMARY_OUTPUT_RUN_2.csv", row.names = F)
write.csv(marginal_var2_2, "SY2025CHNK_marginal_var2_SUMMARY_OUTPUT_RUN_2.csv", row.names = F)
write.csv(est_escp_rearType2, "SY2025CHNK_rearType_SUMMARY_OUTPUT_RUN_2.csv", row.names = F)

# Save RUN 2 workspace objects
save(est_comp2, templates2, est_escp2, full_est_escp2, est_escp_rearType2, marginal_var2_2,
     file = "SY2025CHNK_ANALYSIS_RUN_2_numBoots1000.rda")

# RUN 3 ----------------------------------------------------------------
# W = Stock, Saltwater Age; H = Release Group; HNC = Release Group
# This run produces Figure 5 (wild fish by saltwater age) and Table 2

setwd("C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Output/Run3")

RUN <- "RUN_3"
w <- c("GenStock", "swAge")  # Wild: estimate by stock, then saltwater age within stock
h <- c("releaseGroup")
hnc <- c("releaseGroup")

# Estimate composition (~15 min with 1000 bootstraps)
est_comp3 <- HNC_expand_unkGSI(trap = trap, stratAssign_comp = stratComp, 
                               boots = numBoots,
                               pbt_var = "releaseGroup", timestep_var = "sWeek", 
                               physTag_var = "physTag", adclip_var = "LGDMarkAD", 
                               sampID = "MasterID", tagRates = tagRates,
                               H_vars = h, HNC_vars = hnc, W_vars = w, 
                               wc_binom = exp_wc, GSI_draws = gsi_draws_NA_probfish, 
                               n_point = ceiling(.1 * numBoots), GSI_var = "GenStock",
                               method = "MLE")

beep(sound = 8)
save(est_comp3, file = "SY2025CHNK_est_comp_RUN3.RData")
write.csv(est_comp3[[1]], 'SY2025CHNK_est_comp1_RUN3.csv', row.names = F)
write.csv(est_comp3[[2]], 'SY2025CHNK_est_comp2_boots_RUN3.csv', row.names = F)

templates3 <- apply_fallback_rates(breakdown = est_comp3, fallback_rates = nf$fallback_rates,
                                   split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                   H_groups = NULL, HNC_groups = NULL, W_groups = NULL,
                                   stratAssign_fallback = stratFallback, stratAssign_comp = stratComp, 
                                   alpha_ci = alpha_ci, output_type = "summary")

templates3$HNC <- templates3$HNC %>% mutate(stockGroup = "upper")
templates3$H <- templates3$H %>% mutate(stockGroup = "upper")
templates3$W <- templates3$W %>% mutate(stockGroup = "upper")

est_escp3 <- apply_fallback_rates(breakdown = est_comp3, fallback_rates = nf$fallback_rates,
                                  split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                  H_groups = templates3$H, HNC_groups = templates3$HNC, W_groups = templates3$W,
                                  stratAssign_fallback = stratFallback, stratAssign_comp = stratComp, 
                                  alpha_ci = alpha_ci, output_type = "summary")

est_escp_rearType3 <- est_escp3$rearType

full_est_escp3 <- apply_fallback_rates(breakdown = est_comp3, fallback_rates = nf$fallback_rates,
                                       split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                       H_groups = templates3$H, HNC_groups = templates3$HNC, W_groups = templates3$W,
                                       stratAssign_fallback = stratFallback, stratAssign_comp = stratComp,
                                       alpha_ci = alpha_ci, output_type = "full")

marginal_var2_3 <- full_est_escp3$output %>%
  filter(!is.na(var2)) %>% group_by(rear, var2) %>%
  summarise(pointEst = sum(pointEst), .groups = "drop_last") %>%
  left_join(
    bind_rows(full_est_escp3$boot_breakdown_H, full_est_escp3$boot_breakdown_HNC, full_est_escp3$boot_breakdown_W) %>%
      filter(!is.na(var2)) %>% group_by(rear, var2, boot) %>% summarise(total = sum(total), .groups = "drop_last") %>%
      summarise(lci = quantile(total, alpha_ci / 2), uci = quantile(total, 1 - (alpha_ci / 2)), .groups = "drop_last"),
    by = c("rear", "var2"))

# RUN 3 - Round estimates to whole fish
full_est_escp3$output <- full_est_escp3$output %>% mutate(across(where(is.numeric), \(x) round(x, 0)))
marginal_var2_3 <- marginal_var2_3 %>% mutate(across(where(is.numeric), \(x) round(x, 0)))
est_escp_rearType3 <- est_escp_rearType3 %>% mutate(across(where(is.numeric), \(x) round(x, 0)))

write.csv(full_est_escp3$output, "SY2025CHNK_full_est_escp_SUMMARY_OUTPUT_RUN_3.csv", row.names = F)
write.csv(marginal_var2_3, "SY2025CHNK_marginal_var2_SUMMARY_OUTPUT_RUN_3.csv", row.names = F)
write.csv(est_escp_rearType3, "SY2025CHNK_rearType_SUMMARY_OUTPUT_RUN_3.csv", row.names = F)

# Save RUN 3 workspace objects
save(est_comp3, templates3, est_escp3, full_est_escp3, est_escp_rearType3, marginal_var2_3,
     file = "SY2025CHNK_ANALYSIS_RUN_3_numBoots1000.rda")

# RUN 4 ----------------------------------------------------------------
# This run estimates brood-year composition within each wild stock.
# It is the ONLY run that uses BY, so missing BY values on singleton
# wild fish can trigger the EASE error:
#
#   "Need complete cases for all quantities in stratum X"
#
# When a stratum contains only ONE wild fish from a stock AND that
# fish has BY = NA, the model cannot estimate composition for that
# stock in that stratum. The official fix (per Carli & Tom, Step 5)
# is to set that fish’s GenStock to NA across all GSI draws so that
# it is treated as “GSI-missing” rather than causing a failed cell.
#
# IMPORTANT: This fix ONLY affects RUN 4. Runs 1–3 do NOT use BY,
# and DO NOT need to be rerun. This is normal and expected behavior.

setwd("C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Output/Run4")

RUN <- "RUN_4"
w <- c("GenStock", "BY")  # Wild: estimate stock, then brood year
h <- c("releaseGroup")    # Hatchery: estimate by release group
hnc <- c("releaseGroup")  # HNC: estimate by release group

# RUN 4 PREPROCESSING: Find singleton wild fish with missing BY
# This finds ALL fish where:
# 1. They are the ONLY fish in their stratum×GenStock group
# 2. AND they have missing BY
# These fish will cause "Need complete cases" errors in RUN 4.


# NOTE: We removed the following fish from GSI-based BY estimation:
#   c(656057, 656320, 657190, 656768, 649144, 651648)
#
# These fish are ad-intact (AI) and have a GenStock assignment,
# but are missing Brood Year (BY). RUN 4 estimates wild composition
# using W_vars = c("GenStock", "BY"), which requires complete
# GenStock × BY information in every stratum. 
#
# Any AI fish with GenStock assigned but BY = NA causes incomplete
# cases in the GenStock × BY table for its stratum, which leads to:
#
#   "Need complete cases for all quantities in stratum X"
#
# Per EASE Step 5 guidance (Baum 2023 update), we set the GSI draws
# for these fish to NA across all iterations so they are excluded
# from BY estimation but still inform wild/HNC proportions.

# Estimate composition for RUN 4
# (~20 minutes with 1000 bootstraps)
# Note: The rest of the workflow (split ambiguous PBT groups, apply
# fallback, save outputs) follows standard Step 3 procedures.


# Estimate composition (~20 min with 1000 bootstraps)
est_comp4 <- HNC_expand_unkGSI(trap = trap, stratAssign_comp = stratComp, 
                               boots = numBoots,
                               pbt_var = "releaseGroup", timestep_var = "sWeek", 
                               physTag_var = "physTag", adclip_var = "LGDMarkAD", 
                               sampID = "MasterID", tagRates = tagRates,
                               H_vars = h, HNC_vars = hnc, W_vars = w, 
                               wc_binom = exp_wc, GSI_draws = gsi_draws_NA_probfish, 
                               n_point = ceiling(.1 * numBoots), GSI_var = "GenStock",
                               method = "MLE")

beep(sound = 8)
save(est_comp4, file = "SY2025CHNK_est_comp_RUN4.RData")
write.csv(est_comp4[[1]], 'SY2025CHNK_est_comp1_RUN4.csv', row.names = F)
write.csv(est_comp4[[2]], 'SY2025CHNK_est_comp2_boots_RUN4.csv', row.names = F)

templates4 <- apply_fallback_rates(breakdown = est_comp4, fallback_rates = nf$fallback_rates,
                                   split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                   H_groups = NULL, HNC_groups = NULL, W_groups = NULL,
                                   stratAssign_fallback = stratFallback, stratAssign_comp = stratComp, 
                                   alpha_ci = alpha_ci, output_type = "summary")

templates4$HNC <- templates4$HNC %>% mutate(stockGroup = "upper")
templates4$H <- templates4$H %>% mutate(stockGroup = "upper")
templates4$W <- templates4$W %>% mutate(stockGroup = "upper")

est_escp4 <- apply_fallback_rates(breakdown = est_comp4, fallback_rates = nf$fallback_rates,
                                  split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                  H_groups = templates4$H, HNC_groups = templates4$HNC, W_groups = templates4$W,
                                  stratAssign_fallback = stratFallback, stratAssign_comp = stratComp, 
                                  alpha_ci = alpha_ci, output_type = "summary")

est_escp_rearType4 <- est_escp4$rearType

full_est_escp4 <- apply_fallback_rates(breakdown = est_comp4, fallback_rates = nf$fallback_rates,
                                       split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                       H_groups = templates4$H, HNC_groups = templates4$HNC, W_groups = templates4$W,
                                       stratAssign_fallback = stratFallback, stratAssign_comp = stratComp,
                                       alpha_ci = alpha_ci, output_type = "full")

marginal_var2_4 <- full_est_escp4$output %>%
  filter(!is.na(var2)) %>% group_by(rear, var2) %>%
  summarise(pointEst = sum(pointEst), .groups = "drop_last") %>%
  left_join(
    bind_rows(full_est_escp4$boot_breakdown_H, full_est_escp4$boot_breakdown_HNC, full_est_escp4$boot_breakdown_W) %>%
      filter(!is.na(var2)) %>% group_by(rear, var2, boot) %>% summarise(total = sum(total), .groups = "drop_last") %>%
      summarise(lci = quantile(total, alpha_ci / 2), uci = quantile(total, 1 - (alpha_ci / 2)), .groups = "drop_last"),
    by = c("rear", "var2"))

# RUN 4 - Round estimates to whole fish
full_est_escp4$output <- full_est_escp4$output %>% mutate(across(where(is.numeric), \(x) round(x, 0)))
marginal_var2_4 <- marginal_var2_4 %>% mutate(across(where(is.numeric), \(x) round(x, 0)))
est_escp_rearType4 <- est_escp_rearType4 %>% mutate(across(where(is.numeric), \(x) round(x, 0)))

write.csv(full_est_escp4$output, "SY2025CHNK_full_est_escp_SUMMARY_OUTPUT_RUN_4.csv", row.names = F)
write.csv(marginal_var2_4, "SY2025CHNK_marginal_var2_SUMMARY_OUTPUT_RUN_4.csv", row.names = F)
write.csv(est_escp_rearType4, "SY2025CHNK_rearType_SUMMARY_OUTPUT_RUN_4.csv", row.names = F)

# Save RUN 4 workspace objects
save(est_comp4, templates4, est_escp4, full_est_escp4, est_escp_rearType4, marginal_var2_4,
     file = "SY2025CHNK_ANALYSIS_RUN_4_numBoots1000.rda")

# RUN 5 ----------------------------------------------------------------
# W = Stock, Sex; H = Release Group; HNC = Release Group
# This run produces Figure 3 (wild fish by sex)

setwd("C:/Users/david.smith/OneDrive - State of Idaho/EASE CODE/SY2025 CHNK/Output/Run5")

RUN <- "RUN_5"
w <- c("GenStock", "GenSex")  # Wild: estimate by stock, then sex within stock
h <- c("releaseGroup")
hnc <- c("releaseGroup")

# Estimate composition (~20 min with 1000 bootstraps)
est_comp5 <- HNC_expand_unkGSI(trap = trap, stratAssign_comp = stratComp, 
                               boots = numBoots,
                               pbt_var = "releaseGroup", timestep_var = "sWeek", 
                               physTag_var = "physTag", adclip_var = "LGDMarkAD", 
                               sampID = "MasterID", tagRates = tagRates,
                               H_vars = h, HNC_vars = hnc, W_vars = w, 
                               wc_binom = exp_wc, GSI_draws = gsi_draws_NA_probfish, 
                               n_point = ceiling(.1 * numBoots), GSI_var = "GenStock",
                               method = "MLE")

beep(sound = 8)
save(est_comp5, file = "SY2025CHNK_est_comp_RUN5.RData")
write.csv(est_comp5[[1]], 'SY2025CHNK_est_comp1_RUN5.csv', row.names = F)
write.csv(est_comp5[[2]], 'SY2025CHNK_est_comp2_boots_RUN5.csv', row.names = F)

templates5 <- apply_fallback_rates(breakdown = est_comp5, fallback_rates = nf$fallback_rates,
                                   split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                   H_groups = NULL, HNC_groups = NULL, W_groups = NULL,
                                   stratAssign_fallback = stratFallback, stratAssign_comp = stratComp, 
                                   alpha_ci = alpha_ci, output_type = "summary")

templates5$HNC <- templates5$HNC %>% mutate(stockGroup = "upper")
templates5$H <- templates5$H %>% mutate(stockGroup = "upper")
templates5$W <- templates5$W %>% mutate(stockGroup = "upper")

est_escp5 <- apply_fallback_rates(breakdown = est_comp5, fallback_rates = nf$fallback_rates,
                                  split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                  H_groups = templates5$H, HNC_groups = templates5$HNC, W_groups = templates5$W,
                                  stratAssign_fallback = stratFallback, stratAssign_comp = stratComp, 
                                  alpha_ci = alpha_ci, output_type = "summary")

est_escp_rearType5 <- est_escp5$rearType

full_est_escp5 <- apply_fallback_rates(breakdown = est_comp5, fallback_rates = nf$fallback_rates,
                                       split_H_fallback = "var1", split_HNC_fallback = "var1", split_W_fallback = "var1",
                                       H_groups = templates5$H, HNC_groups = templates5$HNC, W_groups = templates5$W,
                                       stratAssign_fallback = stratFallback, stratAssign_comp = stratComp,
                                       alpha_ci = alpha_ci, output_type = "full")

marginal_var2_5 <- full_est_escp5$output %>%
  filter(!is.na(var2)) %>% group_by(rear, var2) %>%
  summarise(pointEst = sum(pointEst), .groups = "drop_last") %>%
  left_join(
    bind_rows(full_est_escp5$boot_breakdown_H, full_est_escp5$boot_breakdown_HNC, full_est_escp5$boot_breakdown_W) %>%
      filter(!is.na(var2)) %>% group_by(rear, var2, boot) %>% summarise(total = sum(total), .groups = "drop_last") %>%
      summarise(lci = quantile(total, alpha_ci / 2), uci = quantile(total, 1 - (alpha_ci / 2)), .groups = "drop_last"),
    by = c("rear", "var2"))

# RUN 5 - Round estimates to whole fish
full_est_escp5$output <- full_est_escp5$output %>% mutate(across(where(is.numeric), \(x) round(x, 0)))
marginal_var2_5 <- marginal_var2_5 %>% mutate(across(where(is.numeric), \(x) round(x, 0)))
est_escp_rearType5 <- est_escp_rearType5 %>% mutate(across(where(is.numeric), \(x) round(x, 0)))

write.csv(full_est_escp5$output, "SY2025CHNK_full_est_escp_SUMMARY_OUTPUT_RUN_5.csv", row.names = F)
write.csv(marginal_var2_5, "SY2025CHNK_marginal_var2_SUMMARY_OUTPUT_RUN_5.csv", row.names = F)
write.csv(est_escp_rearType5, "SY2025CHNK_rearType_SUMMARY_OUTPUT_RUN_5.csv", row.names = F)

# Save RUN 5 workspace objects
save(est_comp5, templates5, est_escp5, full_est_escp5, est_escp_rearType5, marginal_var2_5,
     file = "SY2025CHNK_ANALYSIS_RUN_5_numBoots1000.rda")

#________________________________________________________________________
# TOTAL RUN TIME: Approximately 2 hours for all 5 runs with 1000 bootstraps
#________________________________________________________________________

#________________________________________________________________________
# ADDITIONAL NOTES FOR REPORT GENERATION

# Sample sizes for report tables:
# Use this code to get sample sizes by category for the report
# Exclude problem fish (duplicates or incomplete cases)
# Filter trap data by rear type and count by desired variables

# Example for wild fish by stock and size:
# Samp_sizes <- trap %>% 
#   mutate(rear = ifelse(LGDMarkAD == "AD", "H",
#                       ifelse(physTag | (!is.na(releaseGroup) & releaseGroup != "Unassigned"), "HNC",
#                             ifelse(is.na(releaseGroup), NA, "W")))) %>%
#   filter(!is.na(rear), rear == 'W') %>%
#   count(var1 = GenStock, var2 = lenCat)

# Figure creation will require additional plotting code
# Table formatting will require combining outputs from multiple runs
